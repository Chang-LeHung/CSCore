# 自己动手写并发工具类(Semaphore, CyclicBarrier, CountDownLatch)是什么体验？

## 前言

在本篇文章当中首先给大家介绍三个工具`Semaphore, CyclicBarrier, CountDownLatch`该如何使用，然后会跟大家一起用`ReentrantLock`实现这三个工具。

## 并发工具类的使用

### CountDownLatch

>`CountDownLatch`最主要的作用是允许一个或多个线程等待其他线程完成操作。比如我们现在有一个任务，有$N$个线程会往数组`data[N]`当中对应的位置根据不同的任务放入数据，然后主线程需要将这个数组当中所有的数据进行求和计算！在这样的场景下，我们就可以使用`CountDownLatch`。

上面问题的代码：

```java
import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.CountDownLatch;

public class CountDownLatchDemo {

    public static int[] data = new int[10];

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(10);

        for (int i = 0; i < 10; i++) {
            int temp = i;
            new Thread(() -> {
                Random random = new Random();
                data[temp] = random.nextInt(100001);
                latch.countDown();
            }).start();
        }

        // 只有函数 latch.countDown() 至少被调用10主线程才不会被阻塞
        // 这个10是在CountDownLatch初始化传递的10
        latch.await();
        System.out.println("求和结果为：" + Arrays.stream(data).sum());
    }
}
```

在上面的代码当中，主线程通过调用`latch.await();`将自己阻塞住，然后需要等他其他线程调用方法`latch.countDown()`只有这个方法被调用的次数等于在初始化时给`CountDownLatch`传递的参数时，主线程才会被释放。

### CyclicBarrier

>`CyclicBarrier`它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。我们通常也将`CyclicBarrier`称作**路障**。

示例代码：

```java
public class CycleBarrierDemo {

    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(5);

        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                try {
                    System.out.println(Thread.currentThread().getName() + "开始等待");
                    // 所有线程都会调用这行代码
                    // 在这行代码调用的线程个数不足5
                    // 个的时候所有的线程都会阻塞在这里
                    // 只有到5的时候，这5个线程才会被放行
                    // 所以这行代码叫做同步点
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "等待完成");
            }).start();
        }
    }
}
```



