# 自己动手写并发工具类(Semaphore, CyclicBarrier, CountDownLatch)是什么体验？

## 前言

在本篇文章当中首先给大家介绍三个工具`Semaphore, CyclicBarrier, CountDownLatch`该如何使用，然后会跟大家一起用`ReentrantLock`实现这三个工具。

## 并发工具类的使用

### CountDownLatch

>`CountDownLatch`最主要的作用是允许一个或多个线程等待其他线程完成操作。比如我们现在有一个任务，有$N$个线程会往数组`data[N]`当中对应的位置根据不同的任务放入数据，然后主线程需要将这个数组当中所有的数据进行求和计算！在这样的场景下，我们就可以使用`CountDownLatch`。

上面问题的代码：

```java
import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.CountDownLatch;

public class CountDownLatchDemo {

    public static int[] data = new int[10];

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(10);

        for (int i = 0; i < 10; i++) {
            int temp = i;
            new Thread(() -> {
                Random random = new Random();
                data[temp] = random.nextInt(100001);
                latch.countDown();
            }).start();
        }

        // 只有函数 latch.countDown() 至少被调用10主线程才不会被阻塞
        // 这个10是在CountDownLatch初始化传递的10
        latch.await();
        System.out.println("求和结果为：" + Arrays.stream(data).sum());
    }
}
```



