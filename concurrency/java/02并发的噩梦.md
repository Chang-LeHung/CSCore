# 并发程序的噩梦——数据竞争（Java）

## 前言

在本文当中我主要通过不同线程对同一个数据进行操作的例子，层层递进，跟大家分享我们在并发编程经常使用的方法和并发编程当中会经常遇到的问题。

## 问题介绍

>在本文当中会有一个贯穿全文的例子：不同的线程会对一个全局变量不断的进行加的操作！然后比较结果，具体来说我们设置一个静态类变量`data`，然后使用两个线程循环10万次对`data`进行加一操作！！！

像这种多个线程会存在同时对同一个数据进行修改操作的现象就叫做**数据竞争**。**数据竞争**会给程序造成很多不可预料的结果，让程序存在许多漏洞。



## 并发不安全版本

在这一小节我们先写一个上述问题的并发不安全的版本：

```java
public class Sum {

    public static int data;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 100000; i++)
                data++;
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 100000; i++)
                data++;
        });

        t1.start();
        t2.start();
        // 让主线程等待 t1 和 t2
        // 直到 t1 和 t2 执行完成
        t1.join();
        t2.join();
        System.out.println(data);
    }
}
// 输出结果
131888
```

上面两个线程执行的结果最终都会小于`200000`，为什么会出现这种情况呢？

我们首先来看一下内存的逻辑布局图：

<img src="../../images/concurrency/15.png" alt="15" style="zoom:80%;" />

`data`全局变量保存在**主内存**当中，当现成开始执行的时候会从**主内存**拷贝一份到线程的**工作内存**当中，也就是线程的**本地内存**，在本地进行计算之后就会将**本地内存**当中的数据同步到**主内存**

我们现在来模拟一下出现问题的过程：

- 主内存`data`的初始值等于0，两个线程得到的`data`初始值都等于0。

<img src="../../images/concurrency/16.png" alt="15" style="zoom:80%;" />

- 现在线程一将`data`加一，然后线程一将`data`的值同步回主内存，整个内存的数据变化如下：

<img src="../../images/concurrency/17.png" alt="15" style="zoom:80%;" />

- 现在线程二`data`加一，然后将`data`的值同步回主内存（将原来主内存的值覆盖掉了）：

<img src="../../images/concurrency/18.png" alt="15" style="zoom:80%;" />

我们本来希望`data`的值在经过上面的变化之后变成`2`，但是线程二覆盖了我们的值，因此在多线程情况下，会使得我们最终的结果变小。

## 忙等待（Busy waiting）

那么我们能在不适用锁或者`synchronized`的情况实现上面这个任务吗？答案是可以，这种方法叫做**忙等待**。具体怎么做呢，我们可以用一个布尔值`flag`去标识是那个线程执行`sum++`，我们先看代码然后进行分析：

```java
public class BusyWaiting {

    public static int data;
    public static boolean flag;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 100000; i++) {
                while (flag);
                data++;
                flag = true;
                System.out.println("Thread 1 : " + data);
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 100000; i++) {
                while (!flag) ;
                data++;
                flag = false;
                System.out.println("Thread 2 : " + data);
            }
        });
        t1.start();
        t2.start();
        // 让主线程等待 t1 和 t2
        // 直到 t1 和 t2 执行完成
        t1.join();
        t2.join();
        System.out.println(data);
    }
}
```



## synchronized并发安全版本

`synchronized`是`java`语言的关键字，它可以用来保证程序的原子性。在并发的情况下我们可以用它来保证我们的程序在某个时刻只能有一个线程执行。

```java
public class Sum01 {
    public static int sum;

    public static synchronized void addSum() {
        for (int i = 0; i < 100000; i++)
            sum++;
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(Sum01::addSum);
        Thread t2 = new Thread(Sum01::addSum);

        t1.start();
        t2.start();
        // 让主线程等待 t1 和 t2
        // 直到 t1 和 t2 执行完成
        t1.join();
        t2.join();

        System.out.println(sum);
    }
}

// 输出结果
200000
```

上面的代码`addSum`方法加入了`synchronized`进行修饰，在`java`当中被`synchronized`的静态方法在同一个时刻只能有一个线程能够进入，也就是说上面的代码会让线程`t1`或者`t2`先执行`addSum`函数，然后另外一个线程在进行执行，那这个跟串行执行就一样了。那么我们就可以不在静态方法上加`synchronized`的关键字，可以使用静态代码块：

```java
public class Sum02 {

    public static int sum;
    public static Object lock = new Object();

    public static void addSum() {
        for (int i = 0; i < 100000; i++)
            synchronized (lock) {
            sum++;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(Sum02::addSum);
        Thread t2 = new Thread(Sum02::addSum);
        t1.start();
        t2.start();
        // 让主线程等待 t1 和 t2
        // 直到 t1 和 t2 执行完成
        t1.join();
        t2.join();

        System.out.println(sum);
    }
}
```

上面代码虽然没有使用用`synchronized`修饰的静态方法，但是上面的代码使用了用`synchronized`修饰的同步代码块，在每一个时刻只能有一个线程执行下面这段代码：

```java
// synchronized 修饰的代码块称作同步代码块 ，
// lock 是一个 全局的静态类变量 只有竞争到 lock 对象的线程
// 才能够进入同步代码块 同样的每一个时刻只能有一个线程进入
synchronized (lock) {
    sum++;
}
```

上面代码虽然没有使用静态同步方法（`synchronized`修饰的静态方法），但是有同步代码块（`synchronized`修饰的代码块），在一个代码当中会有`100000`次进入同步代码块，这里也花费很多时间，因此上面的代码的效率也不高。

其实我们可以用一个临时变量存储`100000`次加法的结果，最后一次将结果加入到`data`当中：

```java
public class Sum03 {
    public static int sum;
    public static Object lock = new Object();

    public static void addSum() {
        int tempSum = 0;
        for (int i = 0; i < 100000; i++)
            tempSum++;
        synchronized (lock) {
            sum += tempSum;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(Sum03::addSum);
        Thread t2 = new Thread(Sum03::addSum);
        t1.start();
        t2.start();
        // 让主线程等待 t1 和 t2
        // 直到 t1 和 t2 执行完成
        t1.join();
        t2.join();

        System.out.println(sum);
    }
}
```

