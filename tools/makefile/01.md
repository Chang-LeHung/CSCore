# 一文彻底掌握Makefile

## 介绍

makefile就是一个可以被make命令解析的文件，他定义了一系列编译的规则，帮助我们更加方便、简洁的去完成编译的过程。在一个大工程当中我们会有各种各样的文件，我们可能会分模块去存放各种文件，可能有些文件还依赖其他的文件，因此我们在编译的时候需要先将被依赖的文件先编译，其他文件后编译，而我们使用makefile就可以更好的去完成这件事儿。

## 基本介绍

在很多情况下我们在C/C++的项目当中使用makefile，其实在其他语言的项目也可以使用make和makefile，它不局限于语言的。现在写一个基本的例子：

```makefile
demo: demo.c
	gcc demo.c -o demo

clean:
	rm demo
```

上面是一个makefile的例子，我们简要说明一下makefile的书写规则：

```makefile
编译目标:依赖文件
	编译命令
```

然后我们使用`make`命令去解释执行`makefile`，我们可以使用`make 编译目标`去执行特定的语句，比如在上面的例子当中我们执行`make demo`的话就会执行`gcc demo.c -o demo`命令。

![](../../images/tools/makfile01.png)

其实上面我们也可以直接使用`make`命令，不需要指定编译目标，因为`make`会自己寻找第一个目标作为被执行的目标。

![](../../images/tools/makfile02.png)

在上面的代码当中我们当我们执行`make`的时候寻找到`makefile`文件的第一个目标`demo`，但是因为我没有改动`demo.c`这个文件，而且这个文件已经编译过了，因此我们没有必要再去编译这个文件，这也是`make`给我们提供的一个非常好的特性，我们不需要重新编译已经编译好的文件，这在一个大型项目当中是非常有用的，当我们的项目当中有成千上万的文件的时候，如果我们重新编译每一个文件的话，那么编译的时间消耗是非常大的。因此我们在执行`make`执行执行`clean`编译目标先删除`demo`这个编译结果，然后在执行`make`这次它再找到`demo`目标，而此时`demo`已经被删除了，因此会重新编译。

## Make命令的工作流程

当我们在命令行当中输入`make`的时候他的执行流程如下：

- make命令首先会在当前目录下面寻找makefile或者Makefile文件。
- 寻找到makefile文件之后，他会在文件当中寻找到一个编译目标，比如在上面的makefile文件当中他会找到`demo`这个编译目标，而不是`clean`这个目标，因为`clean`是第二个编译目标。
- 然后make会解析编译目标的依赖，如果这个依赖是其他的编译目标A的话，那么make会先完成它依赖的编译目标A的命令，如果它依赖的编译目标A也存在依赖B的话，make就会去执行依赖的B的编译命令，如此的递归下去，知道有所得依赖目标都存在了，才会完成第一个编译目标的编译，这个也很好理解，只有依赖文件都存在了我们才能够完成正确的编译过程。

make编译的过程为寻找编译目标，依赖关系，如果依赖的文件还存在依赖那么make会一层一层的寻找下去，只要所有的依赖都被成功解析了，才会最终执行第一个编译目标的编译命令。但是在makefile当中不被第一个编译目标的目标的编译命令是不会被执行的，比如上面我们执行make的时候会执行`demo`编译目标，但是不会执行`clean`编译目标。

下面我们写一个例子了解make解析依赖的过程：

```makefile

main: demo.o myprint.o
	gcc demo.o myprint.o -o out
	echo make 解析编译完成

demo.o: demo.c 
	gcc -c demo.c -o demo.o

myprint.o: myprint.c 
	gcc -c myprint.c -o myprint.o

clean:
	rm myprint.o demo.o
```

![](../../images/tools/makfile03.png)

