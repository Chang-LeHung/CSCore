# Makfile总结

在前面的三篇文章[彻底掌握Makefile（一）](https://mp.weixin.qq.com/s?__biz=Mzg3ODgyNDgwNg==&mid=2247486795&idx=1&sn=1da47724ddaa139d87b8994abefef7cd&chksm=cf0c9142f87b1854f619b6f6d744b6f6c570adb726c857b36787cec7a821cebbaf2b6bd6799f&token=1023752079&lang=zh_CN#rd)、[彻底掌握Makefile（二）](https://mp.weixin.qq.com/s?__biz=Mzg3ODgyNDgwNg==&mid=2247486840&idx=1&sn=68fc4d2c10eb8112bd3c1c26b1c38ac5&chksm=cf0c9171f87b186769351ef320efa7e916dc367de9e948da83c30164b235e079340547e28cb5&token=2139521096&lang=zh_CN#rd)和[彻底掌握Makeifle（三）](https://mp.weixin.qq.com/s?__biz=Mzg3ODgyNDgwNg==&mid=2247486881&idx=1&sn=de6d09baa5b844ab29ad942535d58b72&chksm=cf0c91a8f87b18becd5b4121c461943c41a81af5468a874d3f86bb60dae9b5a0ff302c2a96b1&token=2139521096&lang=zh_CN#rd)当中我们仔细介绍了Makefile各种使用方法，在本篇文章当中主要是对前面三篇关于makefile的文章做一个总结，方便大家快速查阅和检查。

## Makefile基础以及小技巧

### Make命令的工作流程

当我们在命令行当中输入`make`的时候他的执行流程如下：

- make命令首先会在当前目录下面寻找makefile或者Makefile文件。
- 寻找到makefile文件之后，他会在文件当中寻找到一个编译目标，比如在上面的makefile文件当中他会找到`demo`这个编译目标，而不是`clean`这个目标，因为`clean`是第二个编译目标。
- 然后make会解析编译目标的依赖，如果这个依赖是其他的编译目标A的话，那么make会先完成它依赖的编译目标A的命令，如果它依赖的编译目标A也存在依赖B的话，make就会去执行依赖的B的编译命令，如此的递归下去，知道有所得依赖目标都存在了，才会完成第一个编译目标的编译，这个也很好理解，只有依赖文件都存在了我们才能够完成正确的编译过程。

### Makefile当中的小技巧

- makefile基本规则

```makefile
编译目标:依赖文件
	编译命令
```

- 一个最基本的makefile

```makefile
main: demo.o myprint.o
	gcc demo.o myprint.o -o out
	echo make 解析编译完成

demo.o: demo.c 
	gcc -c demo.c -o demo.o

myprint.o: myprint.c 
	gcc -c myprint.c -o myprint.o

clean:
	rm myprint.o demo.o out
```

- 在makefile当中使用变量

```makefile
cflags=-c
main: demo.o myprint.o
	gcc demo.o myprint.o -o out

demo.o: demo.c 
	gcc $(cflags) demo.c -o demo.o

myprint.o: myprint.c 
	gcc $(cflags) myprint.c -o myprint.o

clean:
	rm myprint.o demo.o out
```

- 在makefile当中使用include

```makefile
include submakefile

demo.o: demo.c 
	gcc $(cflags) demo.c -o demo.o

myprint.o: myprint.c 
	gcc $(cflags) myprint.c -o myprint.o

clean:
	rm myprint.o demo.o out
```

- 在makefile当中使用PHONY

```makefile
cflags=-c
main: demo.o myprint.o
	gcc demo.o myprint.o -o main

demo.o: demo.c 
	gcc $(cflags) demo.c -o demo.o

myprint.o: myprint.c 
	gcc $(cflags) myprint.c -o myprint.o

clean:
	rm myprint.o demo.o main
.PHONY: clean # 增加这一行
```

- 在makefile当中使用通配符

```makefile
cflags=-c

main: demo.o myprint.o
	gcc demo.o myprint.o -o main

%.o: %.c 
	gcc $(cflags) $<
clean:
	rm myprint.o demo.o main
.PHONY: clean
```

- 在makefile当中使用VPATH自动搜索

```makefile
cflags=-c

VPATH=./files

main: demo.o myprint.o a.o b.o
	gcc demo.o myprint.o a.o b.o -o main

demo.o:demo.c
	gcc $(cflags) demo.c 

myprint.o:myprint.c
	gcc $(cflags) myprint.c 

a.o: a.c
	gcc $(cflags) $<
b.o: b.c 
	gcc $(cflags) $<

clean:
	rm myprint.o demo.o main
.PHONY: clean
```

## Makefile当中进行if判断

