# 这种动态规划你见过吗——状态机动态规划(上)

## 前言

在本片文章当中主要通过介绍各种**股票问题**跟大家介绍**状态机动态规划**，主要了解在**股票问题**当中是如何在动态规划当中进行状态转移的。

## [买卖股票的最佳时机I](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

>示例 1：
>
>输入：[7,1,5,3,6,4]
>
>输出：5
>
>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

>示例 2：
>
>输入：prices = [7,6,4,3,1]
>
>输出：0
>
>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

### 暴力解法

在这个问题当中，我们的任务是在某一天买入股票，然后在未来某天再将股票卖出去，那么我们就可以用一个二重循环，第一层循环遍历每一天的股票，第二层循环遍历该天之后的股票，然后找到差值最大的那一天即可，也就是寻找某天后面价值最高的股票！

```java
class Solution {
  public int maxProfit(int[] prices){
    int ans = 0;
    for (int i = 0; i < prices.length - 1; i++) {
      for (int j = i + 1; j < prices.length; j++) {
        ans = Math.max(ans, prices[j] - prices[i]);
      }
    }
    return ans;
  }

}
```

上面的代码的时间复杂度为$O(n^2)$，空间复杂度为$O(1)$，由于时间复杂度过高，上面的代码在**Leetcode**上面提交会超时。

### 贪心解法

在暴力解法当中我们思考的是寻找某天后面的最大值，在这个问题当中我们可以换一个角度，就是寻找某天前面股票价值最低的那一天，然后在那一天买进，在当天卖出即可，这个效果和上面暴力解法是一样的。这样的话我们可以用一个数组去存某一天前面价值最小的股票，然后做一个减法即可！这样的话我们可以将时间复杂度降低到$O(n)$。

```java
class Solution {
  public int maxProfit(int[] prices) {
    int ans = 0;
    int[] mins = new int[prices.length];
    int min = Integer.MAX_VALUE;
    for (int i = 0; i < prices.length; i++) {
      min = Math.min(min, prices[i]);
      mins[i] = min;
    }
    for (int i = 0; i < prices.length; i++) {
      ans = Math.max(ans, prices[i] - mins[i]);
    }
    return ans;
  }
}
```

上面的代码的时间复杂度为$O(n)$，空间复杂度也是$O(n)$，其实仔细思考一下我们还可以降低空间复杂度：

```java
class Solution {
  public int maxProfit(int[] prices) {
    int low = Integer.MAX_VALUE;
    int ans = 0;
    for (int i = 0; i < prices.length; i++) {
      low = Math.min(prices[i], low);
      ans = Math.max(ans, prices[i] - low);
    }
    return ans;
  }
}
```

我们在第一次遍历的时候可以顺便求出对应位置的能够获取的最大价值，可以避免第二次遍历。在这个情况下我们的时间复杂度为$O(n)$，空间复杂度为$O(1)$。

### 动态规划解法

在求解动态规划问题的时候通常的步骤有一下几个：

- 寻找能够表示状态的数组`dp`，即我们需要寻找`dp`的含义，分析需要用几纬数组表示。
- 通过分析问题，寻找动态转移公式。
- 初始化状态数组。
- 通过分析动态转移方程，确定数组的遍历顺序。

#### 状态表示数组

在这个问题当中我们用一个二维数组去表示我们的状态：

- `dp[i][0]`表示在第`i`天手上没有股票能够获得的最大的收益，比如我们在第一天的没有股票的收益为0元。

- `dp[i][1]`表示在第`i`天手上存在股票能够获得的最大的收益，比如我们在第一天买入股票之后收益为`-prices[0]`。

那么我们最后的答案是`dp[N][0]`，这个表示在最后一天，我们的手中不存在股票，即我们将股票买出去能够获取的最大的收益。

#### 状态转移方程

现在我们来分析一下如何进行状态的转移：

- `dp[i][0]`的状态如何从第`i-1`的状态转移过来：
  - 如果第`i-1`个状态是手中不存在股票，即`dp[i-1][0]`，那么第`i`个状态也没有股票，那么直接是`dp[i][0] = dp[i - 1][0]`，因为没有进行交易。
  - 如果第`i-1`个状态手中存在股票，即`dp[i-1][1]`，那么如果想在第`i`个状态没有股票，那么就需要将股票卖出，那么收益就为`dp[i-1][1] +prices[i]`，即`dp[i][0] = dp[i-1][1] +prices[i]`。
- `dp[i][1]`的状态如何进行转移：
  - 如果第`i-1`个状态是手中不存在股票，即`dp[i-1][0]`，而第`i`个状态有股票，那么`dp[i][0] = -prices[i]`，因为买入股票，而且只能够买入一次，因此直接等于`-prices[i]`即可，注意这里不能是`dp[i - 1][0] - prices[i]`。
  - 如果第`i-1`个状态手中存在股票，即`dp[i-1][1]`，而第`i`个状态有股票，因此不需要进行交易，即`dp[i][1]=dp[i - 1][1]`。

整个代码如下：

```java
class Solution {
  public int maxProfit(int[] prices) {
    int[][] dp = new int[prices.length][2];
    // 初始化数组 dp[0][0] 默认等于0 不用
    // 现实初始化
    dp[0][1] = -prices[0];
    for (int i = 1; i < prices.length; i++) {
      dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
      dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
    }
    return dp[prices.length - 1][0];
  }
}
```

