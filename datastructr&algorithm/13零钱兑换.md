# 深入浅出零钱兑换问题——背包问题的套壳

## 前言

在本篇文章当中主要通过介绍两个算法题，从最基本的问题开始深入浅出零钱兑换问题，帮助大家从动态规划的本源深入理解问题当中的原理，并且学会自己分析问题，再也不怕类似于背包问题的算法题了。

## [零钱兑换](https://leetcode.cn/problems/coin-change/)

### 题目

>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
>
>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
>
>你可以认为每种硬币的数量是无限的。

### 示例

示例1

```java
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

示例2

```java
输入：coins = [2], amount = 3
输出：-1
```

### 状态表示和状态转移方程

在求解动态规划问题的时候通常的步骤有以下几个：

- 寻找能够表示状态的数组`dp`，即我们需要寻找`dp`的含义，分析需要用几纬数组表示具体的状态。
- 通过分析问题，寻找动态转移公式。
- 初始化状态数组。
- 通过分析动态转移方程，确定数组的遍历顺序。

#### 状态表示数组

在背包问题当中通常都是用一个二维数组表示数据的状态，在这个问题当中我们使用一个二维数组`dp`表示我们需要的状态：

`dp[i][j]`表示使用`coins`前`i`种面额的硬币表示金额等于`j`时使用的最少的金币，那么我们最终答案就是`dp[N][amount]`，他表示使用`coins`数组当中所有面额的硬币表示`amount`需要的最少的硬币个数。

#### 寻找动态转移方程

在确定了状态表示的数组之后，现在我们就需要分析出动态转移方程了，在这个问题当中对于每一种面额的硬币我们都有两种选择：**选和不选**，但是在这个问题当中题目已经说明了对于每一种货币都可以认为是无限的，如果我们不选择，那这种情况比较简单，但是如果选择了这种情况就比较复杂了：

- 不选，这种情况比较简单，比如对于`dp[i][j]`，如果第`i`种面额的货币不选择，那么说明只使用前`i - 1`种面额的货币，那么`dp[i][j] = dp[i - 1][j]`，也就是说明如果使用前`i`种面额的货币去表示总额为`j`，但是不选择第`i`种面额的货币，就相当于使用前`i-1`种货币去表示`j`，那么需要的货币个数跟使用前`i-1`种货币去表示`j`需要的货币数目是相等的。
- 选，这种情况看起来就比较复杂了，因为我们需要确定是选一次，还是选两次，......，还是选N次，但是其实仔细思考一下我们可以使用一个类似递归的形式去解决这个问题，如果选择那么`dp[i][j] = dp[i][j - coins[i]] + 1`，我们仔细分析一下这个公式，相当于在总金额等于`j`的情况下先使用一次第`i`个面额的硬币，但是因为我们的硬币是无限的，现在我们还是可以选择第`i`个硬币，相当于总金额等于`j - coins[i]`而且可以使用前`i`个硬币的情况下，需要的最少的硬币个数，这就解决了是选一次还是选N次的问题了，而在上面的公式当中加一的原因是使用了一次第`i`种硬币。

很显然我们需要从上面两种情况当中选择需要的硬币最少的一种方法，因此综合上面的结果又如下的动态转移方程：
$$
dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i]] + 1)
$$
其实上面这个问题的分析过程跟**完全背包**可以说是一模一样，如果你对**完全背包**感兴趣，你可以阅读这篇文章[完全背包](https://mp.weixin.qq.com/s?__biz=Mzg3ODgyNDgwNg==&mid=2247484544&idx=1&sn=c4de17583010430fa519ecd1703bedea&chksm=cf0c9889f87b119fe5621bacf417b163020dcd8a7c0ed63df94de20ba67ae742b4d86e22ae16&token=883596793&lang=zh_CN#rd)。

#### 初始化状态数组

上面的问题分析过程当中，我们已经分析出来了动态转移方程，这个过程和**完全背包**非常相似，但是这个问题比完全背包还稍微复杂一点，因为不一定能够寻找到这样一种组合凑成的总金额等于题目当中规定的数目。我们用`-1`表示找不到这样一种组合能够表示。

- 在正式初始化之前先将`dp`数组第一行当中的数据全部初始化为-1。
- 初始化第一行代码如下：

```java
for (int i = 0; i * coins[0] <= amount; i++) {
    dp[0][i * coins[0]] = i;
}
```

`dp`数组的第一行表示只使用第一种面额的硬币，因此只有第一种硬币面额的整数倍总金额才能使用第一种硬币进行表示，而且对应的硬币个数等于$\frac{amout}{coins[0]}$。

#### 再看状态转移数组：

- 如果`dp[i][j - coins[i]] == -1`，那么就不能通过选择第`i`种硬币进行表示，在这种情况下，我们只能通过选择前`i-1`一种货币进行表示，即`dp[i][j] = dp[i - 1][j]`。可你你会有疑问，如果也不能使用前`i-1`种物品进行表示呢？没关系，如果不能表示那么`dp[i - 1][j] == -1`，那么赋值之后`dp[i][j]`也等于-1，也是不能表示的。
- 如果`dp[i][j - coins[i]]`不等于-1，但是`dp[i - 1][j]`等于-1，那么`dp[i][j] = dp[i][j - coins[i]] + 1`。
- 如果两者都不等于-1，那么我们就有如下的状态转移公式了：

$$
dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i]] + 1)
$$

### 代码

```java
class Solution {
  public int coinChange(int[] coins, int amount) {
    int[][] dp = new int[coins.length][amount + 1];
    Arrays.fill(dp[0], -1);
    for (int i = 0; i * coins[0] <= amount; i++) {
      dp[0][i * coins[0]] = i;
    }
    for (int i = 1; i < coins.length; i++) {
      for (int j = 0; j <= amount; j++) {
        // 如果要使用对应的硬币 
        // 总金额数目肯定要大于硬币的面额
        if (j >= coins[i]) {
          if (dp[i][j - coins[i]] == -1)
            dp[i][j] = dp[i - 1][j];
          else if (dp[i - 1][j] == -1)
            dp[i][j] = dp[i][j - coins[i]] + 1;
          else
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - coins[i]] + 1);
        } else {
          // 否则只能使用前 i-1 种硬币
          dp[i][j] = dp[i - 1][j];
        }
      }
    }
    return dp[coins.length - 1][amount];
  }
}
```

上面的代码体现的就是**完全背包** 的思想，在题目当中硬币可以使用无限次，如果只能使用一次的话，问题就转换成**01背包**了，那么动态转移方程就为：
$$
dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - coins[i]] + 1)
$$

### 单行数组优化

<img src="../images/dsal/dp/01-dp32.png" alt="01-dp01" style="zoom:100%;" />

根据动态转移方程$dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i]] + 1)$，我们可以得到`dp`数组当中数据之间的依赖关系，他们的关系如上图所示，`dp[i][j]`依赖的数据为它上一行同列的位置，和第`i`行前面的某些数据，事实上我们可以使用单行数组去进行实现，我们使用的循环还是一样的，但是使用的数组有所变化，从之前的二维数组变成一维数组。当我们遍历到单行数组第`j`个数据的时候，第`j`个数据还是上一行的状态，但是单行数组的下标从0到`j-1`的位置数据的状态已经从上一行更新了，这些数据的状态相当于二维数组的`dp[i]`这一行的状态，而这正好可以满足动态转移方程的需求，因为在动态转移方程当中，`dp[i-1][j]`依赖的数据全部符合条件，单行数组当中的下标为`j`数据等于`dp[i][j]`，单行数组下标为`x`的数据等于`dp[i][x]`，其中$0 \le x \le j$，这里你可以结合代码、文字和图片进行理解，理解效果会更加好一点。

<img src="../images/dsal/dp/01-dp31.png" alt="01-dp01" style="zoom:100%;" />

```java
class Solution {
  public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, -1);
    dp[0] = 0;
    for (int i = 0; i < coins.length; i++) {
      for (int j = coins[i]; j <= amount; j++)  {
        if (dp[j - coins[i]] != -1) {
          if (dp[j] == -1) {
            dp[j] = dp[j - coins[i]] + 1;
          }else
            dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
        }
      }
    }
    return dp[amount];
  }
}
```

### 另一种角度思考问题

在上面的文章当中，我们是使用-1去表示不能够找到一个组合满足总金额数目。我们可以先将数组当中所有的数据全部初始化成`amount + 1`，这个是硬币的上界，如果我们全部使用一块的硬币进行兑换，结果是`amount`，因此最大的值不会超过`amount + 1`，因为在动态转移方程当中求的是最小值，因此在进行状态转移的时候不会选择这个值，因此下面的代码也是正确的！！！

```java
class Solution {
  public int coinChange(int[] coins, int amount) {
    int max = amount + 1;
    int[] dp = new int[amount + 1];
    for (int j = 0; j < dp.length; j++) {
      dp[j] = max;
    }
    dp[0] = 0;
    for (int i = 0; i < coins.length; i++) {
      for (int j = coins[i]; j <= amount; j++) {
        if (dp[j - coins[i]] != max) {
          dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
        }
      }
    }
    return dp[amount] == max ? -1 : dp[amount];
  }
}
```

## [零钱兑换 II](https://leetcode.cn/problems/coin-change-2/)

### 题目

>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
>
>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
>
>假设每一种面额的硬币有无限个。 
>
>题目数据保证结果符合 32 位带符号整数。

### 示例

示例1

```java
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

示例2

```java
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
```

### 状态表示和状态转移方程

#### 状态表示数组

在这个问题当中我们也是使用一个二维数组表示我们的状态`dp[i][j]`。这个表示使用前`i`个硬币，总金额为`j`的情况下，能够找到多少种组合方式，是硬币的和等于总金额数。

在这道题目当中我们也可以使用无数次硬币，因此这也是一个**完全背包**问题。

#### 寻找动态转移方程

对于每一种硬币同样的有两种情况选择和不选择，每一种情况都有不同的组合，因此最终的组合数目就是将这两个结果相加：

- 选择，在这个情况下我们能够获得不同的组合数就是`dp[i][j - coins[i]]`，这个代码的含义就是选择一次第`i`个硬币，因为有无数个硬币，因此这个结果就等于使用前`i`个硬币组合总金额为`j-coins[i]`时，一共有多少个组合。
- 不选择，如果不进行选择，那么久相当于使用前`i - 1`个硬币，组合总金额为`j`时，一共有多少个组合。

因此最终的组合数的个数就是上面两种方式的不同组合个数相加，因此我们的动态转移方程为：
$$
dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]];
$$

#### 初始化状态数组

### 代码

```java
class Solution {
  public int change(int amount, int[] coins) {
    int[][] dp = new int[coins.length][amount + 1];
    // dp[i][j] 的含义：前 i 个钱 容量 j 有多少种方法
    for (int i = 0; i * coins[0] <= amount; i++) {
      dp[0][i * coins[0]] = 1;
    }
    for (int i = 1; i < coins.length; i++) {
      for (int j = 0; j <= amount; j++) {
        if (j >= coins[i]) {
          dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]];
        } else
          dp[i][j] = dp[i - 1][j];
      }
    }
    return dp[coins.length - 1][amount];
  }
}
```

