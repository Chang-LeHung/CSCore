# 深入浅出零钱兑换问题——背包问题的套壳

## 前言

在本篇文章当中主要通过介绍两个算法题，从最基本的问题开始深入浅出零钱兑换问题，帮助大家从动态规划的本源深入理解问题当中的原理，并且学会自己分析问题，再也不怕类似于背包问题的算法题了。

## [零钱兑换](https://leetcode.cn/problems/coin-change/)

### 题目

>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
>
>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
>
>你可以认为每种硬币的数量是无限的。

### 示例

示例1

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

示例2

```
输入：coins = [2], amount = 3
输出：-1
```

### 状态表示和状态转移方程

在背包问题当中通常都是用一个二维数组表示数据的状态，在这个问题当中我们使用一个二维数组`dp`表示我们需要的状态：

`dp[i][j]`表示使用`coins`前`i`种面额的硬币表示金额等于`j`时使用的最少的金币，那么我们最终答案就是`dp[N][amount]`，他表示使用`coins`数组当中所有面额的硬币表示`amount`需要的最少的硬币个数。



如果你还不懂**完全背包**，你可以先阅读这篇文章[完全背包](https://mp.weixin.qq.com/s?__biz=Mzg3ODgyNDgwNg==&mid=2247484544&idx=1&sn=c4de17583010430fa519ecd1703bedea&chksm=cf0c9889f87b119fe5621bacf417b163020dcd8a7c0ed63df94de20ba67ae742b4d86e22ae16&token=883596793&lang=zh_CN#rd)。