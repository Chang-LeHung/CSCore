# 深入浅出零钱兑换问题——背包问题的套壳

## 前言

在本篇文章当中主要通过介绍两个算法题，从最基本的问题开始深入浅出零钱兑换问题，帮助大家从动态规划的本源深入理解问题当中的原理，并且学会自己分析问题，再也不怕类似于背包问题的算法题了。

## [零钱兑换](https://leetcode.cn/problems/coin-change/)

### 题目

>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
>
>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
>
>你可以认为每种硬币的数量是无限的。

### 示例

示例1

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

示例2

```
输入：coins = [2], amount = 3
输出：-1
```

### 状态表示和状态转移方程

在求解动态规划问题的时候通常的步骤有以下几个：

- 寻找能够表示状态的数组`dp`，即我们需要寻找`dp`的含义，分析需要用几纬数组表示具体的状态。
- 通过分析问题，寻找动态转移公式。
- 初始化状态数组。
- 通过分析动态转移方程，确定数组的遍历顺序。

#### 状态表示数组

在背包问题当中通常都是用一个二维数组表示数据的状态，在这个问题当中我们使用一个二维数组`dp`表示我们需要的状态：

`dp[i][j]`表示使用`coins`前`i`种面额的硬币表示金额等于`j`时使用的最少的金币，那么我们最终答案就是`dp[N][amount]`，他表示使用`coins`数组当中所有面额的硬币表示`amount`需要的最少的硬币个数。

#### 寻找动态转移方程

在确定了状态表示的数组之后，现在我们就需要分析出动态转移方程了，在这个问题当中对于每一种面额的硬币我们都有两种选择：**选和不选**，但是在这个问题当中题目已经说明了对于每一种货币都可以认为是无限的，如果我们不选择，那这种情况比较简单，但是如果选择了这种情况就比较复杂了：

- 不选，这种情况比较简单，比如对于`dp[i][j]`，如果第`i`种面额的货币不选择，那么说明只使用前`i - 1`种面额的货币，那么`dp[i][j] = dp[i - 1][j]`，也就是说明如果使用前`i`种面额的货币去表示总额为`j`，但是不选择第`i`种面额的货币，就相当于使用前`i-1`种货币去表示`j`，那么需要的货币个数跟使用前`i-1`种货币去表示`j`需要的货币数目是相等的。

如果你还不懂**完全背包**，你可以先阅读这篇文章[完全背包](https://mp.weixin.qq.com/s?__biz=Mzg3ODgyNDgwNg==&mid=2247484544&idx=1&sn=c4de17583010430fa519ecd1703bedea&chksm=cf0c9889f87b119fe5621bacf417b163020dcd8a7c0ed63df94de20ba67ae742b4d86e22ae16&token=883596793&lang=zh_CN#rd)。