# 这种动态规划你见过吗——状态机动态规划之股票问题(下)

## 前言

在前面的两篇文章[这种动态规划你见过吗——状态机动态规划之股票问题(上)](https://mp.weixin.qq.com/s?__biz=Mzg3ODgyNDgwNg==&mid=2247485286&idx=1&sn=3d0a6a1c2e62ba770d8427c6dd732973&chksm=cf0c9b6ff87b1279d46c775001fd77b8e1437d4001a6c8a1ca8db090eadb4174af1058a1aadf&token=1092368950&lang=zh_CN#rd)和[这种动态规划你见过吗——状态机动态规划之股票问题(中)](https://mp.weixin.qq.com/s?__biz=Mzg3ODgyNDgwNg==&mid=2247485500&idx=1&sn=f9283ccc6e0c909641eadb9c761f6d1b&chksm=cf0c9435f87b1d23f1361bdd62946d3e6bb79b1415718fd15150bd47215b5ab490510bb51967&token=1092368950&lang=zh_CN#rd)已经谈了4道和股票问题相关的题目，详细解释了**状态机动态规划**和他的基本原理和应用方式。在本篇文章当中，会再介绍剩下的两道股票问题，继续深入和学习**状态机动态规划**。

## [ 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

### 题目

>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。
>
>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
>
>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

### 示例

示例1:

```
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

示例2:

```
输入: prices = [1]
输出: 0
```

### 状态表示数组和状态转移方程

和前面的题目一样首先还是需要进行状态的定义和状态转移的分析，在这个问题当中我们用一个二维数组`dp[i][j]`表示各种不同的状态下的收益，在这个问题当中我们有以下几个状态：

- `dp[i][0]`，表示在遍历到第`i`支股票的时候没有进行一次买入和卖出。

  - 在这个时候没有进行买入和卖出，这个时候的收益和遍历到第`i-1`支股票的时候没有买入和卖出的情况是一样的，他们的收益都等于0，即`dp[i][0] = 0`，`dp[i - 1][0] = 0`。

- `dp[i][1]`，表示在遍历到第`i`支股票的时候手中含有股票，这个情况可以由**三**种情况转移过来：

  - 在遍历到第`i-1`支股票的时候手中已经存在股票了，这个时候只需要保持状态，那么在第`i`支股票的时候的收益和第`i-1`支股票的收益是相等的，即`dp[i][1] = dp[i - 1][1]`。
  - 第二种情况就是在遍历到第`i-1`支股票的时候手中不存在股票，那么这个时候要想手中存在股票就需要进行买入了，那么久需要花费`prices[i]`，那么在遍历到第`i`支股票的时候收益等于`dp[i][1] = dp[i - 1][0] - prices[i]`。
  - 第三种情况是前一天是处于冷冻期（这里所谈到的冷冻期并不只是前2天卖出，导致的前一天的冷冻期，还有可能是更早之前卖出的，然后保持它的状态），那么现在是可以进行买入的，即`dp[i][1] = dp[i - 1][3]`，其中`dp[i][3]`表示遍历到第`i`支股票的时候处于冷冻期的收益。
  - 综合以上三种情况：

  $$
  dp[i][1] = max(dp[i - 1][1], max(dp[i - 1][0] - prices[i], dp[i-1][3] - prices[i]))
  $$

- `dp[i][2]`，表示在第`i`支股票的时候手中不含有股票，可以转移到这个状态的状态一共有两种：

  - 在遍历到第`i-1`支股票的时候手中本来就不含有股票，那么我们只需要保持状态即可，即`dp[i][2] = dp[i - 1][2]`。
  - 在遍历到第`i-1`支股票的时候手中含有股票，那么我们需要将这个股票进行售出，即`dp[i][2] = dp[i - 1][1] + prices[i]`。
  - 综合以上两种情况：

  $$
  dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])
  $$

- `dp[i][3]`，表示在第`i`支股票的时候是处在冷冻期，这个状态只能由一个状态转移过来，那就是前一天手中没有股票（因为进行卖出了），即`dp[i][3] = dp[i][2]`。

### 数组的初始化和遍历顺序

根据上面的分析我们可以知道，在遍历到第一支股票的时候如果持有股票的话就需要进行买入，那么买入的状态`dp[0][1]`的值就等于`-prices[0]`，卖出的状态收益为0，冷静期的状态也等于0。根据状态转移方程第`i`行的数据以来第`i-1`行，因此从前往后遍历就行。

### 代码

```java
class Solution {
  public int maxProfit(int[] prices) {
    // dp[i][0] 表示一次买入和卖出操作都没有 这个值始终等于0，可以不用这个状态
    // 但是为了完整将这个状态留下来了
    // dp[i][1] 表示持有股票
    // dp[i][2] 表示不持有股票
    // dp[i][3] 卖出操作之后的冷冻期
    int[][] dp = new int[prices.length][4];
    dp[0][1] = -prices[0];
    for (int i = 1; i < prices.length; ++i) {
      dp[i][1] = Math.max(Math.max(dp[i - 1][1], dp[i - 1][3] - prices[i]),
          dp[i][0] - prices[i]); // 因为dp[i][0] 始终等于0 因此这里可以直接写 -prices[i] 也行
      dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
      dp[i][3] = dp[i - 1][2];
    }
    return Math.max(dp[prices.length - 1][2], dp[prices.length - 1][3]);
  }
}
```

因为`dp[i][0]`始终等于0，所以将将所由含`dp[i][0]`的地方都可以删除，因此下面的代码也是正确的。

```java
class Solution {
  public int maxProfit(int[] prices) {
    // dp[i][0] 表示一次买入和卖出操作都没有 这个值始终等于0，可以不用这个状态
    // 但是为了完整将这个状态留下来了
    // dp[i][1] 表示持有股票
    // dp[i][2] 表示不持有股票
    // dp[i][3] 卖出操作之后的冷冻期
    int[][] dp = new int[prices.length][4];
    dp[0][1] = -prices[0];
    for (int i = 1; i < prices.length; ++i) {
      dp[i][1] = Math.max(Math.max(dp[i - 1][1], dp[i - 1][3] - prices[i]),
          -prices[i]); 
      dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
      dp[i][3] = dp[i - 1][2];
    }
    return Math.max(dp[prices.length - 1][2], dp[prices.length - 1][3]);
  }
}
```

### 数组优化——滚动数组

在上面的状态转移方程当中我们始终只使用了两行的数据，因此我们可以只使用一个两行的二维数组，然后进行交替使用（对i求2的余数就可以了）就可以了，代码如下：

```java
class Solution {
  public int maxProfit(int[] prices) {
    int[][] dp = new int[2][4];
    dp[0][1] = -prices[0];
    for (int i = 1; i < prices.length; ++i) {
      dp[i & 1][1] = Math.max(Math.max(dp[(i - 1) & 1][1], dp[(i - 1) & 1][3] - prices[i]),
          dp[i & 1][0] - prices[i]);
      dp[i & 1][2] = Math.max(dp[(i - 1) & 1][2], dp[(i - 1) & 1][1] + prices[i]);
      dp[i & 1][3] = dp[(i - 1) & 1][2];
    }
    return Math.max(dp[(prices.length - 1) & 1][2], dp[(prices.length - 1) & 1][3]);
  }
}
```

## [买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

### 题目

>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。
>
>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
>
>返回获得利润的最大值。
>
>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
>

### 示例

示例1

```
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
```

示例2

```
输入：prices = [1,3,7,5,10,3], fee = 3
输出：6
```

