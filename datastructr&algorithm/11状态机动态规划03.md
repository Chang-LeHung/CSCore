# 这种动态规划你见过吗——状态机动态规划之股票问题(下)

## 前言

在前面的两篇文章[这种动态规划你见过吗——状态机动态规划之股票问题(上)](https://mp.weixin.qq.com/s?__biz=Mzg3ODgyNDgwNg==&mid=2247485286&idx=1&sn=3d0a6a1c2e62ba770d8427c6dd732973&chksm=cf0c9b6ff87b1279d46c775001fd77b8e1437d4001a6c8a1ca8db090eadb4174af1058a1aadf&token=1092368950&lang=zh_CN#rd)和[这种动态规划你见过吗——状态机动态规划之股票问题(中)](https://mp.weixin.qq.com/s?__biz=Mzg3ODgyNDgwNg==&mid=2247485500&idx=1&sn=f9283ccc6e0c909641eadb9c761f6d1b&chksm=cf0c9435f87b1d23f1361bdd62946d3e6bb79b1415718fd15150bd47215b5ab490510bb51967&token=1092368950&lang=zh_CN#rd)已经谈了4道和股票问题相关的题目，详细解释了**状态机动态规划**和他的基本原理和应用方式。在本篇文章当中，会再介绍剩下的两道股票问题，继续深入和学习**状态机动态规划**。

## [ 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

### 题目

>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。
>
>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
>
>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

### 示例

示例1:

```
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

示例2:

```
输入: prices = [1]
输出: 0
```

### 状态表示数组和状态转移方程

和前面的题目一样首先还是需要进行状态的定义和状态转移的分析，在这个问题当中我们用一个二维数组`dp[i][j]`表示各种不同的状态下的收益，在这个问题当中我们有以下几个状态：

- `dp[i][0]`，表示在遍历到第`i`支股票的时候没有进行一次买入和卖出。

  - 在这个时候没有进行买入和卖出，这个时候的收益和遍历到第`i-1`支股票的时候没有买入和卖出的情况是一样的，他们的收益都等于0，即`dp[i][0] = 0`，`dp[i - 1][0] = 0`。

- `dp[i][1]`，表示在遍历到第`i`支股票的时候手中含有股票，这个情况可以由**三**种情况转移过来：

  - 在遍历到第`i-1`支股票的时候手中已经存在股票了，这个时候只需要保持状态，那么在第`i`支股票的时候的收益和第`i-1`支股票的收益是相等的，即`dp[i][1] = dp[i - 1][1]`。
  - 另一中情况就是在遍历到第`i-1`支股票的时候手中不存在股票，那么这个时候要想手中存在股票就需要进行买入了，那么久需要花费`prices[i]`，那么在遍历到第`i`支股票的时候收益等于`dp[i][1] = dp[i - 1][0] - prices[i]`。
  - 第三种情况是前一天是处于冷冻期，那么现在是可以进行买入的，即`dp[i][1] = dp[i - 1][3]`，其中`dp[i][3]`表示遍历到第`i`支股票的时候处于冷冻期的收益。
  - 综合以上三种情况：

  $$
  dp[i][1] = max(dp[i - 1][1], max(dp[i - 1][0] - prices[i], dp[i-1][3] - prices[i]))
  $$

- `dp[i][2]`，表示在第`i`支股票的时候手中不含有股票，可以转移到这个状态的状态一共有两种：

  - 在遍历到第`i-1`支股票的时候手中本来就不含有股票，那么我们只需要保持状态即可，即`dp[i][2] = dp[i - 1][2]`。
  - 在遍历到第`i-1`支股票的时候手中含有股票，那么我们需要将这个股票进行售出，即`dp[i][2] = dp[i - 1][1] + prices[i]`。
  - 综合以上两种情况：

  $$
  dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])
  $$

- `dp[i][3]`，表示在第`i`支股票的时候是处在冷冻期，这个状态只能由一个状态转移过来，那就是前一天手中没有股票，即`dp[i][3] = dp[i][2]`。



### 代码

```java
class Solution {
  public int maxProfit(int[] prices) {
    // dp[i][0] 表示一次买入和卖出操作都没有 这个值始终等于0，可以不用这个状态
    // 但是为了完整将这个状态留下来了
    // dp[i][1] 表示持有股票
    // dp[i][2] 表示不持有股票
    // dp[i][3] 卖出操作之后的冷冻期
    int[][] dp = new int[prices.length][4];
    dp[0][1] = -prices[0];
    for (int i = 1; i < prices.length; ++i) {
      dp[i][1] = Math.max(Math.max(dp[i - 1][1], dp[i - 1][3] - prices[i]),
          dp[i][0] - prices[i]); // 因为dp[i][0] 始终等于0 因此这里可以直接写 -prices[i] 也行
      dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
      dp[i][3] = dp[i - 1][2];
    }
    return Math.max(dp[prices.length - 1][2], dp[prices.length - 1][3]);
  }
}
```

### 数组优化

```java
class Solution {
  public int maxProfit(int[] prices) {
    int[][] dp = new int[2][4];
    dp[0][1] = -prices[0];
    for (int i = 1; i < prices.length; ++i) {
      dp[i & 1][1] = Math.max(Math.max(dp[(i - 1) & 1][1], dp[(i - 1) & 1][3] - prices[i]),
          dp[i & 1][0] - prices[i]);
      dp[i & 1][2] = Math.max(dp[(i - 1) & 1][2], dp[(i - 1) & 1][1] + prices[i]);
      dp[i & 1][3] = dp[(i - 1) & 1][2];
    }
    return Math.max(dp[(prices.length - 1) & 1][2], dp[(prices.length - 1) & 1][3]);
  }
}
```



