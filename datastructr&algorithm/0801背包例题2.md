# 01背包面试题系列（二）

## 题目描述——[最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

> 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。
>
> 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
>
> 如果 x == y，那么两块石头都会被完全粉碎；
> 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
> 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。
>
> 示例 1：
>
> 输入：stones = [2,7,4,1,8,1]
> 输出：1
> 解释：
> 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
> 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
> 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
> 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
> 示例 2：
>
> 输入：stones = [31,26,33,21,40]
> 输出：5

## 问题分析

在读完题目之后，我们的第一感觉就是，如果我们能过恰好将所有的物品分成重量相同的两堆就好了，这样最终剩下的石头的重量就等于0！比如说我们分成的两堆石头的重量分别为`[1, 2, 3, 4, 5]`, `[10, 2, 3]`，那么我们就可以使用`[2, 3, 5]`和`[10]`进行碰撞，这样最后剩下的重量为0， 现在还剩下`[1, 4]`和`[2, 3]`，那么我们可以使用`[4]`和`[3]`进行碰撞，那么剩下的为`[1, 1]`和`[2]`，那么碰完之后剩下石头的重量就等于0了。

在经过上面的例子之后你看你已经理解为什么我们要将所有的石头尽可能的分成两堆重量一样的了，即使重量不一样我们也需要尽可能的将他们之间的差距变小，最后剩下的物品的重量就等于所有物品的重量和减去重量较小的一堆的2倍。

那么我们现在的任务就变成了

## 总结

本文主要给大家介绍**分割等和子集**这个题目，这个题目的即可以使用动态规划进行求解也能使用回溯法进行求解，但是回溯法求解问题的时间复杂度太高。使用动态规划求解的方法还是比较抽象，可能需要大家花时间好好琢磨一下，希望大家有所收获，我是LeHung，我们下期再见！！！（记得**点赞**收藏哦！）

---

更多精彩内容合集可访问项目：<https://github.com/Chang-LeHung/CSCore>

关注公众号：一无是处的研究僧，了解更多计算机（Java、Python、计算机系统基础、算法与数据结构）知识。

![](https://img2022.cnblogs.com/blog/2519003/202207/2519003-20220703200459566-1837431658.jpg)

