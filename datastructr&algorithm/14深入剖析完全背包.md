# 完全背包转化为多重背包

在本篇文章当中主要给大家介绍如何将完全背包问题转化成多重背包问题，在前面的文章[完全背包](https://mp.weixin.qq.com/s?__biz=Mzg3ODgyNDgwNg==&mid=2247484544&idx=1&sn=c4de17583010430fa519ecd1703bedea&chksm=cf0c9889f87b119fe5621bacf417b163020dcd8a7c0ed63df94de20ba67ae742b4d86e22ae16&token=883596793&lang=zh_CN#rd)当中，我们仔细的介绍了完全背包的状态转移方程、根据状态转移方程如何完成代码以及多重背包的数组优化的原理，为什么这种优化能够有效！本篇文章主要专注于如何将完全背包转化成多重背包。

## 完全背包问题

>有$N$种物品和一个容量是 $V$的背包，每种物品都有**无限件可用**。第$i$ 种物品的体积是 $v_i$，价值是$w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

完全背包问题和01背包的唯一区别就在于物品的个数，在01背包当中所有的物品只有一件，也就只能使用一次。而在完全背包当中物品可以使用无限多次。

比如下面的4个物品，背包能够承受的最大重量为5，我们应该如何选择，使得我们获得的总价值最大：

| 物品 | 重量 | 价值 |
| ---- | ---- | ---- |
| A    | 1    | 2    |
| B    | 2    | 4    |
| C    | 3    | 4    |
| D    | 4    | 5    |

这个问题还是比较简单，我们直接从图中看，我们可以选择五个`A`或者两个`B`一个`A`，可以产生最大的收益，最大收益为10。

## 动态转移方程

在前面的文章[完全背包](https://mp.weixin.qq.com/s?__biz=Mzg3ODgyNDgwNg==&mid=2247484544&idx=1&sn=c4de17583010430fa519ecd1703bedea&chksm=cf0c9889f87b119fe5621bacf417b163020dcd8a7c0ed63df94de20ba67ae742b4d86e22ae16&token=883596793&lang=zh_CN#rd)当中我们仔细介绍了完全背包的动态转移方程。我们用一个二位数组`dp[i][j]`表示当只使用前`i`个物品切背包容量为`j`的时候，我们能够获取的最大的收益。

和01背包问题一样首先对于第`i`个物品，首先需要判断背包是否能够容纳（`v[i]`表示第`i`件物品的体积，`w[i]`表示第`i`件物品的价值）：

- 如果背包的容量大于等于第`i`个物品的体积，那我们就有两种选择：
  - 将第`i`个物品放入背包当中，但是在这里需要注意的一点是完全背包的物品有无数件，因此当我们选择之后我们的转移方程为`dp[i][j - v[i]] + w[i]`，这里不是`i-1`而是`i`，因为第`i`件物品有无数件。
  - 不将第`i`个物品放入背包当中，那么我们就能够使用容量为`j`的背包去选择前`i - 1`个物品，这种情况下我们的最大收益为`dp[i - 1][j]`。
- 如果背包容量小于第`i`件物品的体积，我们就不能够选择第`i`件物品了，这种情况下我们的最大收益为`dp[i - 1][j]`。

基于上面的分析我们可以知道完全背包问题的动态转移方程为：
$$
dp[i][j] = \begin{cases}
max(dp[i][j - v[i]] + w[i], dp[i - 1][j]), j \ge v[i]\\
dp[i - 1][j] , j \lt v[i]
\end{cases}
$$
根据上面的状态转移方程，我们的核心代码如下（其中N表示物品的个数，V表示背包的容量，w[i]表示第i个物品的价值，v[i]表示第i个物品所占的体积）：

```c++
int backpack() {
  for (int i = 1; i < N; ++i) {
    for (int j = 0; j <= V; ++j) {
        if (j >= v[i]) {
            dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]);
        }
        else {
            dp[i][j] = dp[i - 1][j];
        }
    }
	}
  return dp[V];
}
```

但是上面的代码我们可以进行数组优化，优化之后的代码如下（如果你还不是很清楚优化原理的话，你可以阅读[完全背包](https://mp.weixin.qq.com/s?__biz=Mzg3ODgyNDgwNg==&mid=2247484544&idx=1&sn=c4de17583010430fa519ecd1703bedea&chksm=cf0c9889f87b119fe5621bacf417b163020dcd8a7c0ed63df94de20ba67ae742b4d86e22ae16&token=883596793&lang=zh_CN#rd)当中的数组优化小节）：

```java
int backpack() {
	for (int i = 0; i < N; ++i) {
		for (int j = v[i]; j <= V; ++j) {
			dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
		}
	}
	return dp[V];
}
```

## 问题转化

我们知道完全背包问题当中的物品时可以无限次使用的，但是实质上我们不可能拿无限个物品，因为我们的背包容量是有限的，假如我们的背包容量为`V`物品的体积为`v`，那么我们能够拿的最大的个数就是：
$$
\lfloor \frac{V}{v} \rfloor
$$
因此我们这样就将一个完全背包问题转化成了多重背包问题，每一个物品的最大数量就是：
$$
\lfloor\frac{V}{v_i}\rfloor
$$
上面的公式简单的说来就是拿的所有的物品所占的体积不能超过背包的容量。因此我们可以重写完全背包的状态转移方程：
$$
dp[i][j] = 
max\\
\{ \\
dp[i - 1][j], \\
dp[i - 1][j - v[i]] + w[i],\\
dp[i - 1][j - v[i] * 2] + w[i] * 2, \\
..., \\
dp[i - 1][j - v[i] * T] + w[i] * T\\
\}
$$
其中 $T = \lfloor\frac{V}{v_i}\rfloor$。

因此完全背包转多重背包的代码如下（进行数组优化之后的代码）：

```C++

#include <iostream>

using namespace std;

#define MAX_LENGTH 2000

int N, V;

int values[MAX_LENGTH];
int volumes[MAX_LENGTH];
int dp[MAX_LENGTH];

void complete_backpack() {
  // 前面两侧循环和正常的 dp 循环一样
  for (int i = 0; i < N; ++i) {
    for (int j = V; j >= volumes[i]; j--) {
      for(int k = 1; j >= volumes[i] * k; k++) {
        dp[j] = max(dp[j], dp[j - volumes[i] * k] + values[i] * k);
      }
    }
  }
}


int main() {
  cin >> N >> V;
  for (int i = 0; i < N; i++) {
    cin >> volumes[i] >> values[i];
  }
  complete_backpack();
  printf("%d", dp[V]);
  return 0;
}

```

