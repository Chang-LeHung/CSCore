# 面试官：完全背包都不会，是你自己走还是我送你？

## 完全背包问题

>有$N$种物品和一个容量是 $V$的背包，每种物品都有**无限件可用**。第$i$ 种物品的体积是 $v_i$，价值是$w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

完全背包问题和01背包的唯一区别就在于物品的个数，在01背包当中所有的物品只有一件，也就只能使用一次。而在完全背包当中物品可以使用无限多次。

比如下面的4个物品，背包能够承受的最大重量为5，我们应该如何选择，使得我们获得的总价值最大：

| 物品 | 重量 | 价值 |
| ---- | ---- | ---- |
| A    | 1    | 2    |
| B    | 2    | 4    |
| C    | 3    | 4    |
| D    | 4    | 5    |

这个问题还是比较简单，我们直接从图中看，我们可以选择五个`A`或者两个`B`一个`A`，可以产生最大的收益，最大收益为10。

## 完全背包问题分析

### 01背包动态转移方程分析

在01背包问题当中，我们是使用一个二维数组`dp[i][j]`进行计算，`dp[i][j]`表示在只使用前`i`个物品且背包容量为`j`的情况下，我们能够获得的最大的收益。在这个情况下，我们根据当前背包容量`j`判断是否能装入第`i`个物品可以得到下面两个方程（下面公式字母的含义与上文完全背包问题所提到的一致）。
$$
dp[i][j] = \begin{cases}
max(dp[i - 1][j - v[i]] + w[i], dp[i - 1][j]), j \ge v[i]\\
dp[i - 1][j] , j \lt v[i]
\end{cases}
$$
上面01背包的公式的第二条比较简单，如果背包容量不足以容纳第`i`件物品，那么只能从前`i - 1`物品当中选择了。我们来仔细分析一下第一条公式。

如果当前背包容量可以容纳第`i`个物品，那么我们就可以选择第`i`件物品或者不选择，我们应该选择两种选择当中收益更大的那个。

- 如果我们不选择第`i`个物品，那么我们就能够使用容量为`j`的背包去选择前`i - 1`个物品，这种情况下我们的最大收益为`dp[i - 1][j]`。
- 如果选择第`i`个物品，那么我们背包容量还剩下`j - v[i]`，还可以选择剩下的`i - 1`个物品，而且我们的收益需要加上`w[i]`，因此我们的收益为`dp[i - 1][j - v[i]] + w[i], dp[i - 1][j])`。

### 完全背包动态转移方程分析

和01背包问题一样首先对于第`i`个物品，首先需要判断背包是否能够容纳：

- 如果背包的容量大于等于第`i`个物品的体积，那我们就有两种选择：
  - 将第`i`个物品放入背包当中，但是在这里需要注意的一点是完全背包的物品有无数件，因此当我们选择之后我们的转移方程为`dp[i][j - v[i]] + w[i]`，这里不是`i-1`而是`i`，因为第`i`件物品有无数件。
  - 不将第`i`个物品放入背包当中，那么我们就能够使用容量为`j`的背包去选择前`i - 1`个物品，这种情况下我们的最大收益为`dp[i - 1][j]`。
- 如果背包容量小于第`i`件物品的体积，我们就不能够选择第`i`件物品了，这种情况下我们的最大收益为`dp[i - 1][j]`。

基于上面的分析我们可以知道完全背包问题的动态转移方程为：
$$
dp[i][j] = \begin{cases}
max(dp[i][j - v[i]] + w[i], dp[i - 1][j]), j \ge v[i]\\
dp[i - 1][j] , j \lt v[i]
\end{cases}
$$

## 代码分析

根据对动态转移方程的分析，我们可以知道，我们在计算`dp[i][j]`这个数据的值的时候，我们首先需要将`dp[i][j - v[i]]`和`dp[i - 1][j])`的结果计算出来，因为`dp[i][j]`依赖这两个数据。

<img src="../images/dsal/dp/01-dp26.png" alt="01-dp01" style="zoom:100%;" />

根据上面的分析和图我们知道，在计算`dp[i][j]`之前，我们需要将第`i`行第`j`列之前的数据和`dp[i - 1][j]`都计算出来，因为`dp[i][j]`依赖这些数据。而我们最终需要的结果是`dp[N][V]`表示在背包容量为`V`且能够前`N`个物品（也就是所以物品）能够获得的最大的收益。

因此基于以上分析，我们要想最终解出`dp[N][V]`的值，我们可以采取两重`for`循环，第一重循环遍历物品，第二重循环遍历容量，那么我么的代码可以写成下面这样：

```c++
#include <iostream>
using namespace std;

#define MAX_LEN 1001

int w[MAX_LEN];
int v[MAX_LEN];
int dp[MAX_LEN][MAX_LEN];
// path 表示动态转移方程的选择类别
// 如果转移方向为 dp[i][j - v[i]] + w[i] 用箭头←表示
// 如果转移方向为 dp[i - 1][j] 用箭头↑表示
string path[MAX_LEN][MAX_LEN] = {""};
int N, V;

int backpack() {
	for (int i = v[0]; i <= V; ++i) {
		dp[0][i] = max(dp[0][i], dp[0][i - v[0]] + w[0]);
		path[0][i] = "←";
	}
	for (int i = 1; i < N; ++i) {
        for (int j = 0; j <= V; ++j) {
            if (j >= v[i]) {
                if (dp[i - 1][j] > (dp[i][j - v[i]] + w[i])) {
                    dp[i][j] = dp[i - 1][j];
                    path[i][j] = "↑";
                }else {
                    dp[i][j] = dp[i][j - v[i]] + w[i];
                    path[i][j] = "←";
                }
            }
            else {
                dp[i][j] = dp[i - 1][j];
                path[i][j] = "↑";
            }
        }
	}
	return dp[N - 1][V];
}

int main() {

    cin >> N >> V;
    for (int i = 0; i < N; ++i) {
        cin >> v[i] >> w[i];
    }
    cout << backpack() << endl;
    for (int i = 0; i < N; ++i) {
        for (int j = 1; j <= V; ++j) {
            cout << path[i][j] << " ";
        }
        cout << "\n";
    }
	return 0;
}

```



